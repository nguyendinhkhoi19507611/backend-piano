
const mongoose = require('mongoose');

const musicSchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, 'Music title is required'],
    trim: true,
    maxlength: [200, 'Title cannot exceed 200 characters']
  },
  artist: {
    type: String,
    required: [true, 'Artist name is required'],
    trim: true,
    maxlength: [100, 'Artist name cannot exceed 100 characters']
  },
  album: {
    type: String,
    trim: true,
    maxlength: [150, 'Album name cannot exceed 150 characters']
  },
  genre: {
    type: String,
    required: true,
    enum: [
      'pop', 'rock', 'jazz', 'classical', 'electronic', 'hip-hop', 
      'country', 'folk', 'blues', 'reggae', 'metal', 'punk',
      'alternative', 'indie', 'rnb', 'soul', 'funk', 'disco',
      'techno', 'house', 'trance', 'dubstep', 'ambient', 'world'
    ]
  },
  duration: {
    type: Number, // Tính bằng giây
    required: true,
    min: [10, 'Song must be at least 10 seconds'],
    max: [600, 'Song cannot exceed 10 minutes']
  },
  difficulty: {
    level: {
      type: String,
      enum: ['easy', 'medium', 'hard', 'expert'],
      required: true
    },
    rating: {
      type: Number,
      min: 1,
      max: 10,
      required: true
    },
    keyCount: {
      type: Number,
      min: 1,
      max: 88, // Piano có 88 phím
      required: true
    },
    tempo: {
      type: Number, // BPM
      min: 60,
      max: 200,
      required: true
    }
  },
  audio: {
    url: {
      type: String,
      required: true
    },
    format: {
      type: String,
      enum: ['mp3', 'wav', 'ogg', 'm4a'],
      default: 'mp3'
    },
    quality: {
      type: String,
      enum: ['low', 'medium', 'high', 'lossless'],
      default: 'high'
    },
    size: {
      type: Number // Tính bằng bytes
    }
  },
  sheet: {
    notes: [{
      time: {
        type: Number, // Timestamp trong bài hát (ms)
        required: true
      },
      key: {
        type: String, // Tên phím piano (C4, D#4, etc.)
        required: true,
        match: /^[A-G]([#b])?[0-8]$/
      },
      duration: {
        type: Number, // Thời gian giữ phím (ms)
        default: 100
      },
      velocity: {
        type: Number, // Độ mạnh (0-127)
        min: 0,
        max: 127,
        default: 80
      },
      type: {
        type: String,
        enum: ['note', 'chord', 'pause'],
        default: 'note'
      }
    }],
    keySignature: {
      type: String,
      default: 'C'
    },
    timeSignature: {
      type: String,
      default: '4/4'
    },
    sections: [{
      name: {
        type: String,
        enum: ['intro', 'verse', 'chorus', 'bridge', 'outro', 'solo']
      },
      startTime: Number,
      endTime: Number,
      difficulty: String
    }]
  },
  licensing: {
    type: {
      type: String,
      enum: ['free', 'premium', 'licensed', 'original'],
      required: true
    },
    copyright: {
      owner: String,
      year: Number,
      notice: String
    },
    royalties: {
      enabled: {
        type: Boolean,
        default: false
      },
      rate: {
        type: Number,
        min: 0,
        max: 1,
        default: 0
      },
      recipient: String
    },
    usage: {
      commercial: {
        type: Boolean,
        default: false
      },
      modification: {
        type: Boolean,
        default: false
      },
      distribution: {
        type: Boolean,
        default: false
      }
    }
  },
  metadata: {
    releaseDate: Date,
    language: {
      type: String,
      default: 'en'
    },
    country: String,
    label: String,
    isrc: String, // International Standard Recording Code
    tags: [String],
    mood: {
      type: String,
      enum: ['happy', 'sad', 'energetic', 'calm', 'aggressive', 'romantic', 'mysterious']
    },
    instruments: [String]
  },
  statistics: {
    playCount: {
      type: Number,
      default: 0
    },
    likeCount: {
      type: Number,
      default: 0
    },
    averageScore: {
      type: Number,
      default: 0
    },
    averageAccuracy: {
      type: Number,
      default: 0
    },
    completionRate: {
      type: Number,
      default: 0
    },
    difficulty: {
      community: {
        type: Number,
        min: 1,
        max: 10
      },
      votes: {
        type: Number,
        default: 0
      }
    }
  },
  features: {
    hasLyrics: {
      type: Boolean,
      default: false
    },
    hasChords: {
      type: Boolean,
      default: false
    },
    hasPedal: {
      type: Boolean,
      default: false
    },
    multiHand: {
      type: Boolean,
      default: false
    },
    autoGenerated: {
      type: Boolean,
      default: false
    }
  },
  availability: {
    regions: [String], // ISO country codes
    ageRating: {
      type: String,
      enum: ['G', 'PG', 'PG-13', 'R'],
      default: 'G'
    },
    premium: {
      type: Boolean,
      default: false
    },
    unlockConditions: {
      level: Number,
      score: Number,
      achievement: String
    }
  },
  quality: {
    verified: {
      type: Boolean,
      default: false
    },
    verifiedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    verifiedAt: Date,
    issues: [{
      type: {
        type: String,
        enum: ['audio_quality', 'sync_issue', 'wrong_notes', 'copyright', 'inappropriate']
      },
      description: String,
      reportedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      reportedAt: {
        type: Date,
        default: Date.now
      },
      status: {
        type: String,
        enum: ['open', 'investigating', 'resolved', 'rejected'],
        default: 'open'
      }
    }]
  },
  status: {
    type: String,
    enum: ['draft', 'pending', 'published', 'archived', 'deleted'],
    default: 'draft'
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtuals
musicSchema.virtual('durationFormatted').get(function() {
  const minutes = Math.floor(this.duration / 60);
  const seconds = this.duration % 60;
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
});

musicSchema.virtual('difficultyScore').get(function() {
  const weights = { easy: 1, medium: 2, hard: 3, expert: 4 };
  return weights[this.difficulty.level] * this.difficulty.rating;
});

musicSchema.virtual('popularityScore').get(function() {
  return (this.statistics.playCount * 0.4) + 
         (this.statistics.likeCount * 0.6) + 
         (this.statistics.averageScore * 0.1);
});

musicSchema.virtual('isPopular').get(function() {
  return this.statistics.playCount > 100 && this.statistics.averageScore > 7000;
});

musicSchema.virtual('noteCount').get(function() {
  return this.sheet.notes.length;
});

musicSchema.virtual('notesPerSecond').get(function() {
  return this.noteCount / this.duration;
});

// Indexes for search and performance
musicSchema.index({ title: 'text', artist: 'text', album: 'text' });
musicSchema.index({ genre: 1, 'difficulty.level': 1 });
musicSchema.index({ 'statistics.playCount': -1 });
musicSchema.index({ 'statistics.averageScore': -1 });
musicSchema.index({ status: 1, 'availability.premium': 1 });
musicSchema.index({ createdAt: -1 });
musicSchema.index({ 'metadata.tags': 1 });

// Pre-save middleware
musicSchema.pre('save', function(next) {
  // Tính toán difficulty rating dựa trên notes
  if (this.isModified('sheet.notes') && this.sheet.notes.length > 0) {
    const noteDensity = this.noteCount / this.duration;
    const tempoFactor = this.difficulty.tempo / 120; // 120 BPM làm baseline
    
    let calculatedRating = Math.min(10, Math.max(1, 
      (noteDensity * 2) + (tempoFactor * 2) + (this.difficulty.keyCount / 10)
    ));
    
    this.difficulty.rating = Math.round(calculatedRating);
    
    // Auto-assign difficulty level
    if (calculatedRating <= 3) {
      this.difficulty.level = 'easy';
    } else if (calculatedRating <= 6) {
      this.difficulty.level = 'medium';
    } else if (calculatedRating <= 8) {
      this.difficulty.level = 'hard';
    } else {
      this.difficulty.level = 'expert';
    }
  }
  
  // Validate notes format
  if (this.sheet.notes.length > 0) {
    this.sheet.notes.forEach(note => {
      if (note.time < 0 || note.time > this.duration * 1000) {
        throw new Error('Note time is outside song duration');
      }
    });
    
    // Sort notes by time
    this.sheet.notes.sort((a, b) => a.time - b.time);
  }
  
  next();
});

// Instance methods
musicSchema.methods.incrementPlayCount = function() {
  this.statistics.playCount += 1;
  return this.save();
};

musicSchema.methods.updateScore = function(newScore, accuracy) {
  const totalGames = this.statistics.playCount || 1;
  this.statistics.averageScore = ((this.statistics.averageScore * (totalGames - 1)) + newScore) / totalGames;
  this.statistics.averageAccuracy = ((this.statistics.averageAccuracy * (totalGames - 1)) + accuracy) / totalGames;
  return this.save();
};

musicSchema.methods.addLike = function() {
  this.statistics.likeCount += 1;
  return this.save();
};

musicSchema.methods.removeLike = function() {
  this.statistics.likeCount = Math.max(0, this.statistics.likeCount - 1);
  return this.save();
};

musicSchema.methods.reportIssue = function(type, description, userId) {
  this.quality.issues.push({
    type,
    description,
    reportedBy: userId
  });
  return this.save();
};

musicSchema.methods.verify = function(userId) {
  this.quality.verified = true;
  this.quality.verifiedBy = userId;
  this.quality.verifiedAt = new Date();
  this.status = 'published';
  return this.save();
};

musicSchema.methods.getNotesInTimeRange = function(startTime, endTime) {
  return this.sheet.notes.filter(note => 
    note.time >= startTime && note.time <= endTime
  );
};

musicSchema.methods.generatePreview = function(duration = 30) {
  const previewStart = Math.max(0, (this.duration * 1000 / 2) - (duration * 1000 / 2));
  const previewEnd = previewStart + (duration * 1000);
  
  return {
    startTime: previewStart,
    endTime: previewEnd,
    notes: this.getNotesInTimeRange(previewStart, previewEnd)
  };
};

// Static methods
musicSchema.statics.search = async function(query, filters = {}) {
  const searchQuery = {
    status: 'published',
    ...filters
  };
  
  if (query) {
    searchQuery.$text = { $search: query };
  }
  
  return await this.find(searchQuery)
    .sort({ 'statistics.playCount': -1, score: { $meta: 'textScore' } })
    .limit(50);
};

musicSchema.statics.getRecommendations = async function(userId, limit = 10) {
  // Lấy lịch sử chơi của user để recommend
  const Game = mongoose.model('Game');
  const userGames = await Game.find({ userId }).populate('musicId');
  
  const preferredGenres = {};
  const preferredDifficulty = {};
  
  userGames.forEach(game => {
    if (game.musicId) {
      const genre = game.musicId.genre;
      const difficulty = game.musicId.difficulty.level;
      
      preferredGenres[genre] = (preferredGenres[genre] || 0) + 1;
      preferredDifficulty[difficulty] = (preferredDifficulty[difficulty] || 0) + 1;
    }
  });
  
  const topGenre = Object.keys(preferredGenres).reduce((a, b) => 
    preferredGenres[a] > preferredGenres[b] ? a : b, 'pop');
  const topDifficulty = Object.keys(preferredDifficulty).reduce((a, b) => 
    preferredDifficulty[a] > preferredDifficulty[b] ? a : b, 'easy');
  
  // Recommend based on preferences
  return await this.find({
    status: 'published',
    $or: [
      { genre: topGenre },
      { 'difficulty.level': topDifficulty },
      { 'statistics.playCount': { $gte: 100 } }
    ]
  })
  .sort({ 'statistics.averageScore': -1 })
  .limit(limit);
};

musicSchema.statics.getTrending = async function(period = '7d', limit = 20) {
  const startDate = new Date();
  
  switch (period) {
    case '24h':
      startDate.setDate(startDate.getDate() - 1);
      break;
    case '7d':
      startDate.setDate(startDate.getDate() - 7);
      break;
    case '30d':
      startDate.setDate(startDate.getDate() - 30);
      break;
  }
  
  const Game = mongoose.model('Game');
  
  return await Game.aggregate([
    {
      $match: {
        createdAt: { $gte: startDate },
        'session.status': 'completed'
      }
    },
    {
      $group: {
        _id: '$musicId',
        playCount: { $sum: 1 },
        averageScore: { $avg: '$scoring.totalScore' },
        uniquePlayers: { $addToSet: '$userId' }
      }
    },
    {
      $addFields: {
        uniquePlayerCount: { $size: '$uniquePlayers' },
        trendingScore: {
          $add: [
            { $multiply: ['$playCount', 0.4] },
            { $multiply: ['$averageScore', 0.0001] },
            { $multiply: ['$uniquePlayerCount', 0.6] }
          ]
        }
      }
    },
    {
      $lookup: {
        from: 'music',
        localField: '_id',
        foreignField: '_id',
        as: 'music'
      }
    },
    {
      $unwind: '$music'
    },
    {
      $match: {
        'music.status': 'published'
      }
    },
    {
      $sort: { trendingScore: -1 }
    },
    {
      $limit: limit
    },
    {
      $project: {
        music: 1,
        playCount: 1,
        averageScore: 1,
        uniquePlayerCount: 1,
        trendingScore: 1
      }
    }
  ]);
};

module.exports = mongoose.model('Music', musicSchema);